{"pages":[{"title":"spring","text":"","link":"/spring/index.html"},{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"first","text":"一，Java 位运算 1.表示方法： 在Java语言中，二进制数使用补码表示，最高位为符号位，正数的符号位为0，负数为1。补码的表示需要满足如下要求。 (1)正数的最高位为0，其余各位代表数值本身(二进制数)。 (2)对于负数，通过对该数绝对值的补码按位取反，再对整个数加1。 2.位运算符 位运算表达式由操作数和位运算符组成，实现对整数类型的二进制数进行位运算。位运算符可以分为逻辑运算符(包括~、＆、|和^)及移位运算符(包括&gt;&gt;、&lt;&lt;和&gt;&gt;&gt;)。 1)左移位运算符（&lt;&lt;）能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补0）。 2)“有符号”右移位运算符（&gt;&gt;）则将运算符左边的运算对象向右移动运算符右侧指定的位数。 “有符号”右移位运算符使用了“符号扩展”：若值为正，则在高位插入0；若值为负，则在高位插入1。 3)Java也添加了一种“无符号”右移位运算符（&gt;&gt;&gt;），它使用了“零扩展”：无论正负，都在高位插入0。这一运算符是C或C++没有的。 4)若对char，byte或者short进行移位处理，那么在移位进行之前，它们会自动转换成一个int。 只有右侧的5个低位才会用到。这样可防止我们在一个int数里移动不切实际的位数。 若对一个long值进行处理，最后得到的结果也是long。此时只会用到右侧的6个低位，防止移动超过long值里现成的位数。 但在进行“无符号”右移位时，也可能遇到一个问题。若对byte或short值进行右移位运算，得到的可能不是正确的结果（Java 1.0和Java 1.1特别突出）。 它们会自动转换成int类型，并进行右移位。但“零扩展”不会发生，所以在那些情况下会得到-1的结果。 在进行位运算时，需要注意以下几点。 (1)&gt;&gt;&gt;和&gt;&gt;的区别是：在执行运算时，&gt;&gt;&gt;运算符的操作数高位补0，而&gt;&gt;运算符的操作数高位移入原来高位的值。 (2)右移一位相当于除以2，左移一位(在不溢出的情况下)相当于乘以2；移位运算速度高于乘除运算。 (3)若进行位逻辑运算的两个操作数的数据长度不相同，则返回值应该是数据长度较长的数据类型。 (4)按位异或可以不使用临时变量完成两个值的交换，也可以使某个整型数的特定位的值翻转。 (5)按位与运算可以用来屏蔽特定的位，也可以用来取某个数型数中某些特定的位。 (6)按位或运算可以用来对某个整型数的特定位的值置l。 3．位运算符的优先级 ~的优先级最高，其次是&lt;&lt;、&gt;&gt;和&gt;&gt;&gt;，再次是＆，然后是^，优先级最低的是|。 二， 按位异或运算符^ 参与运算的两个值，如果两个相应位相同，则结果为0，否则为1。即：0^0=0， 1^0=1， 0^1=1， 1^1=0 例如：10100001^00010001=10110000 0^0=0,0^1=1 0异或任何数＝任何数 1^0=1,1^1=0 1异或任何数－任何数取反 任何数异或自己＝把自己置0 (1)按位异或可以用来使某些特定的位翻转，如对数10100001的第2位和第3位翻转，可以将数与00000110进行按位异或运算。 10100001^00000110=10100111 //1010 0001 ^ 0x06 = 1010 0001 ^ 6 (2)通过按位异或运算，可以实现两个值的交换，而不必使用临时变量。 例如交换两个整数a，b的值，可通过下列语句实现： a=10100001,b=00000110 a=a^b； //a=10100111 b=b^a； //b=10100001 a=a^b； //a=00000110 (3)异或运算符的特点是：数a两次异或同一个数b（a=a^b^b）仍然为原值a. 三，Java 中除了二进制的表示方法：","link":"/2019/07/05/first/"},{"title":"","text":"equals和==的区别== 比较的是变量(栈)内存中存放的对象的(堆)内存地址 equals用来比较的是两个对象的内容是否相等。如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。 java.lang.Objectequals hashCode toString clone getClass fin wait notify Static 用法static修饰的方法、类变量叫做静态方法和静态变量，可以通过类名直接访问，被所有的对象所共享，初次加载时会被初始化。另外可以编写static代码块，静态导包 堆和栈的区别1、栈区：存放函数的参数值、局部变量、基本数据类型、对象的地址等，由编译器自动分配和释放，通常在函数执行完后就释放了， 2、堆区：就是通过new、malloc、realloc分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。 类的加载机制类的生命周期自动拆装箱装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的 int 和Integer在进行比较的时候，Integer会进行拆箱，转为int值与int进行比较。 Integer与Integer比较的时候，由于直接赋值的时候会进行自动的装箱，那么这里就需要注意两个问题，一个是-128&lt;= x&lt;=127的整数，将会直接缓存在IntegerCache中，那么当赋值在这个区间的时候，不会创建新的Integer对象，而是从缓存中获取已经创建好的Integer对象。二：当大于这个范围的时候，直接new Integer来创建Integer对象。 new Integer(1) 和Integer a = 1不同，前者会创建对象，存储在堆中，而后者因为在-128到127的范围内，不会创建新的对象，而是从IntegerCache中获取的。那么Integer a = 128, 大于该范围的话才会直接通过new Integer（128）创建对象，进行装箱。 索引的原理InnoDB存储引擎 MyISAM存储引擎 MEMORY存储引擎 功 能 MYISAM Memory InnoDB Archive 存储限制 256TB RAM 64TB None 支持事物 No No Yes No 支持全文索引 Yes No No No 支持数索引 Yes Yes Yes No 支持哈希索引 No Yes No No 支持数据缓存 No N/A Yes No 支持外键 No No Yes No 聚簇索引和非聚簇索引 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据 innodb 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行 MYISAM synchronized与Lock的区别两者区别： 1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类； 2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁； 3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁； 4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； 5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可） 6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 1、Lock是java的一个interface接口，而synchronized是Java中的关键字，synchronized是由JDK实现的，不需要程序员编写代码去控制加锁和释放；Lock的接口如下： 12345678public interface Lock { void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();} 2、synchronized修饰的代码在执行异常时，jdk会自动释放线程占有的锁，不需要程序员去控制释放锁，因此不会导致死锁现象发生；但是，当Lock发生异常时，如果程序没有通过unLock()去释放锁，则很可能造成死锁现象，因此Lock一般都是在finally块中释放锁；格式如下： 123456789Lock lock = new LockImpl; // new 一个Lock的实现类lock.lock(); // 加锁try{ //todo}catch(Exception ex){ // todo}finally{ lock.unlock(); //释放锁} 3、Lock可以让等待锁的线程响应中断处理，如tryLock(long time, TimeUnit unit)，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够中断，程序员无法控制； 4、通过Lock可以知道有没有成功获取锁，tryLock()方法返回boolean值，因此可知道是否获得了锁，而synchronized却无法办到。 5、Lock的实现类ReentrantReadWriteLock提供了readLock()和writeLock()用来获取读锁和写锁的两个方法，这样多个线程可以进行同时读操作。 总体来讲，当并发量较小，资源竞争不激烈时，两者的性能是差不多的；当大量线程同时竞争，资源非常有限时，此时Lock的性能要远远优于synchronized。","link":"/2019/07/17/equals和==的区别/"},{"title":"IDEA","text":"键位：Command，Control，Option，Shift Command+Option+Shift+U 查看类的继承关系（类继承了谁） ⌘ + 7 查看类的结构 ⌥ + Enter 导入包，快速修复 ⌃ + H 打开类层次窗口，查看类的继承关系 智能提示⌘ -&gt; command⇧ -&gt; shift⌥ -&gt; option⬆ -&gt; 上箭头⬇ -&gt; 下箭头⌃ -&gt; Control 编辑 快捷键 说明 ⌘ + F 在当前窗口查找 ⌘ + ⇧ + F 在全工程查找 ⌘ + ⇧ + ⌥ + N 查找类中的方法或变量 F3 / ⇧ + F3 移动到搜索结果的下/上一匹配处 ⌘ + R 在当前窗口替换 ⌘ + ⇧ + R 在全工程替换 ⌘ + ⇧ + V 可以将最近使用的剪贴板内容选择插入到文本 ⌥ + ⇧ + Up/Down 向上/下移一行 ⌘ + ⇧ + Up/Down 向上/下移动语句 ⌘ + / 注释 - // ⌘ + ⇧ + / 注释 - /**/ ⇧ + Enter 向下插入新行 ⌘ + Enter 上插一行 ⌘ + ⇧ + F7 高亮显示所有该文本，按 Esc 高亮消失 ⌘ + W 可以选择单词继而语句继而行继而函数 ⌘ + ⇧ + W 取消选择光标所在词 ⌥ + Left/Right 移动光标到前/后单词 ⌥ + Backspace 按单词删除 ⌘ + [/] 移动到前/后代码块 ⌘ + ⇧ + Left/Right/[/] 选中跳跃范围内的代码 ⌘ + Y/X 删除行 ⌘ + D 复制行 ⌘ + ⇧ + U 大小写转化 ⌘ + ⌥ + V 可以引入变量。例如：new String(); 自动导入变量定义 ⌘ + ⌥ + T 可以把代码包在一个块内，例如：try/catch ⌘ + ⌥ + L 格式化代码 ⌘ + ⌥ + I 将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 ⌘ + ⌥ + O 优化导入的类和包 ⌘ + +/- 当前方法展开、折叠 ⌘ + ⇧ + +/- 全部展开、折叠 重构 快捷键 说明 ⌘ + ⇧ + ⌥ + T 重构功能大汇总快捷键 ⇧ + F6 重命名 ⌘ + ⌥ + V 提取变量 ⌘ + O 重写父类方法 代码生成 快捷键 说明 fori 生成循环 sout System.out.println(); ⌘ + J 可以查看所有代码模板 ⌘ + ⌥ + J 用动态模板环绕 ⌘ + ⇧ + Enter 自动补全末尾的字符（括号，分号），例如敲完if/for时也可以自动补上{}花括号。 ⌥ + Enter 导入包，快速修复 后缀自动补全功能(Postfix Completion) 要输入 for(User user : users) 只需输入 user.for + Tab。 要输入 Date birthday = user.getBirthday(); 只需输入 user.getBirthday().var + Tab 即可。 | 文件 快捷键 说明 ⌘ + Delete 删除文件 ⌃ + ⌥ + N 新建一切文件 F5 复制类 F6 移动类 工具栏 快捷键 说明 ⌃ + H 打开类层次窗口，查看类的继承关系 ⌘ + 1 快速打开或隐藏工程面板 ⇧ + Esc 不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 查找定位 快捷键 说明 ⌘ + F7 可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 ⌥ + F7 查找整个工程中使用地某一个类、方法或者变量的位置 ⇧ + ⇧ Search Everywhere 功能，可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等 ⌘ + N 快速打开某个类 ⌘ + ⇧ + N 快速打开文件或资源 ⌘ + B / ⌘ + Click 快速打开光标处的类或方法（跳转到定义处） ⌘ + ⌥ + B 跳转到方法实现处 F2 / ⇧ + F2 移动到有错误的代码 ⌘ + U 转到父类 ⌘ + G 定位行 ⌘ + ⌥ + left/right 返回至上次浏览的位置 ⌘ + E 最近的文件 ⌘ + ⇧ + E 最近更改的文件 ⌥ + ⇧ + C 最近的更改 ⌥ + F1 查找代码所在位置 ⌘ + ⌥ + F7 显示用法 ⌘ + I 实现方法 ⌘ + ⌥ + N 内联 方法相关 快捷键 说明 ⌘ + P 可以显示参数信息 ⌘ + F12 查看当前文件的结构 调试部分、编译 快捷键 说明 ⌘ + F2 停止 ⌥ + ⇧ + F9 选择 Debug ⌥ + ⇧ + F10 选择 Run ⌘ + ⇧ + F9 编译 ⌘ + ⇧ + F10 运行 ⌘ + ⇧ + F8 查看断点 F7 步入 Step into F8 步过 Step over F9 恢复程序 Continue ⇧ + F7 智能步入 ⇧ + F8 步出 ⌥ + ⇧ + F8 强制步过 ⌥ + ⇧ + F7 强制步入 ⌥ + F9 运行至光标处 ⌥ + F10 定位到断点 ⌘ + ⌥ + F9 强制运行至光标处 ⌘ + F8 切换行断点 ⌘ + F9 生成项目 ⌘ + ⇧ + C 复制路径 ⌘ + ⌥ + ⇧ + C 复制引用，必须选择类名 ⌘ + ⌥ + Y 同步 ⌘ + ~ 快速切换方案（界面外观、代码风格、快捷键映射等菜单） ⇧ + F12 还原默认布局 ⌘ + ⇧ + F12 隐藏/恢复所有窗口 ⌘ + F4 关闭 ⌘ + ⇧ + F4 关闭活动选项卡 ⌘ + Tab 转到下一个拆分器 ⌘ + ⇧ + Tab 转到上一个拆分器 切换窗口 快捷键 说明 ⌘ + 1 项目结构 ⌘ + 2 收藏 ⌘ + 3 搜索结果 ⌘ + 4 运行 ⌘ + 5 调试 ⌘ + 6 TODO ⌘ + 7 结构 ⌃ + Tab 切换 tab 其他 快捷键 说明 ⌘ + ⇧ + A 可以查找所有命令，并且每个命令后面还有其快捷键 在任意菜单或显示窗口，都可以直接输入你要找的单词，idea 就会自动为你过滤。 测试 快捷键 说明 ⌘ + ⌥ + T 创建单元测试用例","link":"/2019/07/19/IDEA/"},{"title":"proint","text":"注解（Annotation）元注解 @Target @Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 取值(ElementType)有： ​ 1.CONSTRUCTOR:用于描述构造器 ​ 2.FIELD:用于描述域​ 3.LOCAL_VARIABLE:用于描述局部变量​ 4.METHOD:用于描述方法​ 5.PACKAGE:用于描述包​ 6.PARAMETER:用于描述参数​ 7.TYPE:用于描述类、接口(包括注解类型) 或enum声明 @Retention @Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。 作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效） 取值（RetentionPoicy）有： 1.SOURCE:在源文件中有效（即源文件保留） 2.CLASS:在class文件中有效（即class保留） 3.RUNTIME:在运行时有效（即运行时保留） @Documented @Documented 标记注解 ：文档化注解生成公共API @Inherited @Inherited 标记注解：如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 自定义注解 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口。 注解参数的可支持数据类型： 1.所有基本数据类型（int,float,boolean,byte,double,char,long,short) 2.String类型 3.Class类型 4.enum类型 5.Annotation类型 6.以上所有类型的数组 Annotation类型里面的参数该怎么设定: 第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型； 第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String; 第三,如果只有一个参数成员,最好把参数名称设为”value”,后加小括号.例:下面的例子FruitName注解就只有一个参数成员。 自定义注解使用过程定义注解——配置注解——解析注解一、 定义注解 12345678@Retention(RetentionPolicy.RUNTIME)@Target(value = {ElementType.METHOD})@Documentedpublic @interface CherryAnnotation { String name(); int age() default 18; int[] score();} 二、 配置注解 12345678public class Student{ @CherryAnnotation(name = \"Tim\",age = 12) public void study(int times){ for(int i = 0; i &lt; times; i++){ System.out.println(\"Good Good Study, Day Day Up!\"); } }} 三、 解析注解 12345678910111213141516171819202122232425public class TestAnnotation { public static void main(String[] args){ try { //获取Student的Class对象 Class stuClass = Class.forName(\"pojos.Student\"); //说明一下，这里形参不能写成Integer.class，应写为int.class Method stuMethod = stuClass.getMethod(\"study\",int.class); if(stuMethod.isAnnotationPresent(CherryAnnotation.class)){ System.out.println(\"Student类上配置了CherryAnnotation注解！\"); //获取该元素上指定类型的注解 CherryAnnotation cherryAnnotation = stuMethod.getAnnotation(CherryAnnotation.class); System.out.println(\"name: \" + cherryAnnotation.name() + \", age: \" + cherryAnnotation.age() + \", score: \" + cherryAnnotation.score()[0]); }else{ System.out.println(\"Student类上没有配置CherryAnnotation注解！\"); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } }} # github.com74.86.151.162 http://global-ssl.fastly.net13.229.188.59 http://github.com 174.86.151.162 github.global.ssl.fastly.net","link":"/2019/07/15/proint/"},{"title":"sprstu_d1","text":"一、XML的解析：解析XML文件，主要把解析成BeanDefinition放入容器（BeanDefinitionMap）1BeanFactory beanFactory = new XmlBeanFactory(new FileUrlResource(\"bean.xml\")); DefaultListableBeanFactory . Static{} ![image-20190721115442725](/Users/kelvin/Library/Application Support/typora-user-images/image-20190721115442725.png) FileUrlResource.FileUrlResource(String location) —&gt; UrlResource.UrlResource(String protocol, String location) — &gt; UrlResource.UrlResource(String protocol, String location, @Nullable String fragment) ![image-20190721140334280](/Users/kelvin/Library/Application Support/typora-user-images/image-20190721140334280.png) XmlBeanFactory.XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) — &gt; DefaultListableBeanFactory — &gt; AbstractAutowireCapableBeanFactory — &gt; AbstractBeanFactory ![image-20190721141245201](/Users/kelvin/Library/Application Support/typora-user-images/image-20190721141245201.png) —————— ![image-20190721143641871](/Users/kelvin/Library/Application Support/typora-user-images/image-20190721143641871.png) XmlBeanDefinitionReader — &gt; EncodedResource ![image-20190721143258416](/Users/kelvin/Library/Application Support/typora-user-images/image-20190721143258416.png) ![image-20190722094831084](/Users/kelvin/Library/Application Support/typora-user-images/image-20190722094831084.png) ![image-20190722095709406](/Users/kelvin/Library/Application Support/typora-user-images/image-20190722095709406.png) ![image-20190722100252500](/Users/kelvin/Library/Application Support/typora-user-images/image-20190722100252500.png) ![image-20190722101552523](/Users/kelvin/Library/Application Support/typora-user-images/image-20190722101552523.png) 默认表空间 DefaultBeanDefinitionDocumentReader.parseDefaultElement ![image-20190722135521906](/Users/kelvin/Library/Application Support/typora-user-images/image-20190722135521906.png) BeanDefinitionParserDelegate 委托类，用来辅助解析标签 ![image-20190723092555027](/Users/kelvin/Library/Application Support/typora-user-images/image-20190723092555027.png) ![image-20190723092645206](/Users/kelvin/Library/Application Support/typora-user-images/image-20190723092645206.png) ![image-20190723092744700](/Users/kelvin/Library/Application Support/typora-user-images/image-20190723092744700.png) ![image-20190723103410394](/Users/kelvin/Library/Application Support/typora-user-images/image-20190723103410394.png) ![image-20190723103448781](/Users/kelvin/Library/Application Support/typora-user-images/image-20190723103448781.png) 标签解析完成得到 BeanDefinition 对象 ，开始注册bean ![image-20190723105626613](/Users/kelvin/Library/Application Support/typora-user-images/image-20190723105626613.png) ![image-20190723105708640](/Users/kelvin/Library/Application Support/typora-user-images/image-20190723105708640.png) 二、Bean的加载 尝试从缓存中加载单例 Spring 创建 bean 的原则是不等 bean 创建完成就会将创建 bean 的ObjectFactory 提早曝光也就是将ObjectFactory 加入到缓存中， 一旦下一个 bean 创建时要依赖上个 bean 则直接使用ObjectFactory直接尝试 缓存获取 或者 singletonFactories 中的 ObjectFactory 获取 ![image-20190725172945311](/Users/kelvin/Library/Application Support/typora-user-images/image-20190725172945311.png) ![image-20190725173047506](/Users/kelvin/Library/Application Support/typora-user-images/image-20190725173047506.png) ![image-20190725173132693](/Users/kelvin/Library/Application Support/typora-user-images/image-20190725173132693.png) 获取单例 问题：BeanFactory和FactoryBean的区别 BeanFactory是IOC容器的核心接口，负责生产和管理bean的一个工厂。主要提供getBean、getBeanProvider、getType、isSingleton、isProtoType、containsBean、getAliases等接口，主要实现类有DefaultListableBeanFactory、XMLBeanFactory、ApplicationContext等实现类 FactoryBean是一个工厂类接口，用户可以通过实现该接口来定制实例化 bean 的逻辑。它提供三个接口getObject（返回由 Factory Bean 创建的 bean 实例，并缓存单例实例）、getObjectType（bean 类型）、isSingleton，当FactoryBean调用 getBean (“xxx”) 时， Spring 通过反射机制发现 CarFactoryBean 实现了 FactoryBean接口，这时 Spring 容器就调用接口方法 CarFactoryBean#getObject（）方法返回 如果希望获取CarFactoryBean 的实例，则需要在使用 getBean(beanName)方法时在 beanName 前显示的加上”＆”前缀，例 getBean(“＆car”). q Q:: scp power.zip monica q q q q q q q q q q q q q q","link":"/2019/07/21/sprstu-d1/"},{"title":"sort","text":"SORT","link":"/2019/07/08/sort/"},{"title":"redis","text":"REDIS0. Redis的五种数据类型和数据结构如果你是 Redis 普通玩家，可能你的回答是如下五种数据结构： 字符串 String Redis的命令不区分大小写，但是key 严格区分大小写 一个key 对应一个 value。string 类型是二进制安全的，意思是 Redis 的 string 可以包含任何数据，比如图片或者序列化的对象，一个 redis 中字符串 value 最多可以是 512M set key1 value1 / get key1 mset k1 v1 k2 v2 k3 v3 / mget k1 k3 : mset 批量操作 setex kex 5 vex 设置过期时间 / setnx k8 v8 如果key存在不做任何操作 ttl key 返回 key 的剩余过期时间，单位为秒 incr key 自增 key++ / decr key 自减 key– incrby key i key += i /decrby key i key -= i； 字典Hash hset key field value [field value …] 新增 hget key field [field …] 获取 hdel key field [field …] 删除 hexists key field 是否存在 hgetall key 获取所有keys和values hincryby key field i == key.field += i; hkeys key 获取所有keys hlen key 获取所有keys的个数 hmget key field [field …] hmset key field value [field value …] hvals key 获取所有values 列表List 集合Set 有序集合 SortedSet 如果你是 Redis 中级玩家，还需要加上下面几种数据结构： HyperLogLog Geo Pub / Sub 如果你是 Redis 高端玩家，你可能玩过 Redis Module ，可以再加上下面几种数据结构： BloomFilter RedisSearch Redis-ML JSON 另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。😈 默默跟面试官在装一波。 1. 缓存穿透、缓存雪崩、缓存击穿2. Redis 使用场景Redis 可用的场景非常之多： 数据缓存 会话缓存 时效性数据 访问频率 计数器 社交列表 记录用户判定信息 交集、并集和差集 热门列表与排行榜 最新动态 消息队列 分布式锁 详细的介绍，可以看看如下文章： 《聊聊 Redis 使用场景》 《Redis 应用场景及实例》 《Redis 常见的应用场景解析》 《Redis 和 Memcached 各有什么优缺点，主要的应用场景是什么样的？》 3. Redis 提高命中率4. 缓存算法 LRU（least recently used ，最近最少使用) LFU（Least Frequently used ，最不经常使用) FIFO（first in first out ，先进先出) 5.常见问题 缓存何时写入？并且写时如何避免并发重复写入？ 缓存如何失效？ 缓存和 DB 的一致性如何保证？ 如何避免缓存穿透的问题？ 如何避免缓存击穿的问题？ 如果避免缓存雪崩的问题？ 6. 什么是缓存预热？如何实现缓存预热？7.Redis 的优点、缺点8.Redis 的线程模型？为什么 Redis 单线程模型也能效率这么高？如何提高多核 CPU 的利用率？9.Redis 有几种持久化方式？面试题redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？ 面试官心理分析redis 如果仅仅只是将数据缓存在内存里面，如果 redis 宕机了再重启，内存里的数据就全部都弄丢了啊。你必须得用 redis 的持久化机制，将数据写入内存的同时，异步的慢慢的将数据写入磁盘文件里，进行持久化。 如果 redis 宕机重启，自动从磁盘上加载之前持久化的一些数据就可以了，也许会丢失少许数据，但是至少不会将所有数据都弄丢。 这个其实一样，针对的都是 redis 的生产环境可能遇到的一些问题，就是 redis 要是挂了再重启，内存里的数据不就全丢了？能不能重启的时候把数据给恢复了？ 面试题剖析持久化主要是做灾难恢复、数据恢复，也可以归类到高可用的一个环节中去，比如你 redis 整个挂了，然后 redis 就不可用了，你要做的事情就是让 redis 变得可用，尽快变得可用。 重启 redis，尽快让它对外提供服务，如果没做数据备份，这时候 redis 启动了，也不可用啊，数据都没了。 很可能说，大量的请求过来，缓存全部无法命中，在 redis 里根本找不到数据，这个时候就死定了，出现缓存雪崩问题。所有请求没有在 redis 命中，就会去 mysql 数据库这种数据源头中去找，一下子 mysql 承接高并发，然后就挂了… 如果你把 redis 持久化做好，备份和恢复方案做到企业级的程度，那么即使你的 redis 故障了，也可以通过备份数据，快速恢复，一旦恢复立即对外提供服务。 redis 持久化的两种方式 RDB：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。 AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。 通过 RDB 或 AOF，都可以将 redis 内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务。 如果 redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 redis，redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。 如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。 RDB 优缺点 RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。 RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。 相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。 如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。 RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。 AOF 优缺点 AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次fsync操作，最多丢失 1 秒钟的数据。 AOF 日志文件以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。 AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。 AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。 对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。 AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低） 以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。 RDB 和 AOF 到底该如何选择 不要仅仅使用 RDB，因为那样会导致你丢失很多数据； 也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug； redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。 10.Redis 有几种数据“过期”策略？Redis 有哪几种数据“淘汰”策略？11.如何使用 Redis 实现分布式锁？12.什么是 Redis 事务？13.什么是 Redis 主从同步？ Redis 分区https://segmentfault.com/a/1190000014507534","link":"/2019/07/11/redis/"},{"title":"two","text":"HashMap的扩容机制—resize() 面试的时候闻到了Hashmap的扩容机制，之前只看到了Hasmap的实现机制，补一下基础知识，讲的非常好 原文链接： http://www.iteye.com/topic/539465 Hashmap是一种非常常用的、应用广泛的数据类型，最近研究到相关的内容，就正好复习一下。网上关于hashmap的文章很多，但到底是自己学习的总结，就发出来跟大家一起分享，一起讨论。 1、hashmap的数据结构要知道hashmap是什么，首先要搞清楚它的数据结构，在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap也不例外。Hashmap实际上是一个数组和链表的结合体（在数据结构中，一般称之为“链表散列“），请看下图（横排表示数组，纵排表示数组元素【实际上是一个链表】）。 从图中我们可以看到一个hashmap就是一个数组结构，当新建一个hashmap的时候，就会初始化一个数组。我们来看看java代码： Java代码 收藏代码/** * The table, resized as necessary. Length MUST Always be a power of two. * FIXME 这里需要注意这句话，至于原因后面会讲到 */ transient Entry[] table; Java代码 收藏代码static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final K key; V value; final int hash; Entry&lt;K,V&gt; next;……….} 上面的Entry就是数组中的元素，它持有一个指向下一个元素的引用，这就构成了链表。 当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。从这里我们可以想象得到，如果每个位置上的链表只有一个元素，那么hashmap的get效率将是最高的，但是理想总是美好的，现实总是有困难需要我们去克服，哈哈~ 2、hash算法我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那？java中时这样做的， Java代码 收藏代码static int indexFor(int h, int length) { return h &amp; (length-1); } 首先算得key得hashcode值，然后跟数组的长度-1做一次“与”运算（&amp;）。看上去很简单，其实比较有玄机。比如数组的长度是2的4次方，那么hashcode就会和2的4次方-1做“与”运算。很多人都有这个疑问，为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高，我以2的4次方举例，来解释一下为什么数组大小为2的幂时hashmap访问的性能最高。 看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ 所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。 说到这里，我们再回头看一下hashmap中默认的数组大小是多少，查看源代码可以得知是16，为什么是16，而不是15，也不是20呢，看到上面annegu的解释之后我们就清楚了吧，显然是因为16是2的整数次幂的原因，在小数据量的情况下16比15和20更能减少key之间的碰撞，而加快查询的效率。所以，在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的，代码如下(HashMap的构造方法中)： Java代码 收藏代码// Find a power of 2 &gt;= initialCapacity int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; 总结： 本文主要描述了HashMap的结构，和hashmap中hash函数的实现，以及该实现的特性，同时描述了hashmap中resize带来性能消耗的根本原因，以及将普通的域模型对象作为key的基本要求。尤其是hash函数的实现，可以说是整个HashMap的精髓所在，只有真正理解了这个hash函数，才可以说对HashMap有了一定的理解。 3、hashmap的resize 当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。4、key的hashcode与equals方法改写在第一部分hashmap的数据结构中，annegu就写了get方法的过程：首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。 Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。在改写equals方法的时候，需要满足以下三点：(1) 自反性：就是说a.equals(a)必须为true。(2) 对称性：就是说a.equals(b)=true的话，b.equals(a)也必须为true。(3) 传递性：就是说a.equals(b)=true，并且b.equals(c)=true的话，a.equals(c)也必须为true。通过改写key对象的equals和hashcode方法，我们可以将任意的业务对象作为map的key(前提是你确实有这样的需要)。 总结： 本文主要描述了HashMap的结构，和hashmap中hash函数的实现，以及该实现的特性，同时描述了hashmap中resize带来性能消耗的根本原因，以及将普通的域模型对象作为key的基本要求。尤其是hash函数的实现，可以说是整个HashMap的精髓所在，只有真正理解了这个hash函数，才可以说对HashMap有了一定的理解。","link":"/2019/07/05/two/"}],"tags":[{"name":"JAVA 位运算","slug":"JAVA-位运算","link":"/tags/JAVA-位运算/"},{"name":"IDEA快捷键","slug":"IDEA快捷键","link":"/tags/IDEA快捷键/"},{"name":"Java HashMap 扩容","slug":"Java-HashMap-扩容","link":"/tags/Java-HashMap-扩容/"}],"categories":[]}