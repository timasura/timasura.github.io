<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>PageOne</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一个好玩的网站">
<meta name="keywords" content="Java Open Book">
<meta property="og:type" content="website">
<meta property="og:title" content="PageOne">
<meta property="og:url" content="https://timasura.github.io/index.html">
<meta property="og:site_name" content="PageOne">
<meta property="og:description" content="一个好玩的网站">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PageOne">
<meta name="twitter:description" content="一个好玩的网站">
  
    <link rel="alternate" href="/atom.xml" title="PageOne" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PageOne</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://timasura.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-studay1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/19/studay1/" class="article-date">
  <time datetime="2019-07-19T09:02:18.000Z" itemprop="datePublished">2019-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/19/studay1/">studay1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://timasura.github.io/2019/07/19/studay1/" data-id="cjy9w8lhe0007lmwilj1jrag6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-IDEA" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/19/IDEA/" class="article-date">
  <time datetime="2019-07-19T01:35:19.000Z" itemprop="datePublished">2019-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/19/IDEA/">IDEA</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>键位：<code>Command</code>，<code>Control</code>，<code>Option</code>，<code>Shift</code></p>
<p><code>Command</code>+<code>Option</code>+<code>Shift</code>+<code>U</code>    查看类的继承关系（类继承了谁）</p>
<p>⌘ + 7   查看类的结构</p>
<p>⌥ + Enter   导入包，快速修复</p>
<p>⌃ + H    打开类层次窗口，查看类的继承关系</p>
<p><img src="/Users/kelvin/img.png" alt="image-20190719164708378"></p>
<h3 id="智能提示"><a href="#智能提示" class="headerlink" title="智能提示"></a>智能提示</h3><p>⌘ -&gt; command<br>⇧ -&gt; shift<br>⌥ -&gt; option<br>⬆ -&gt; 上箭头<br>⬇ -&gt; 下箭头<br>⌃ -&gt; Control</p>
<p>编辑</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>⌘ + F</td>
<td>在当前窗口查找</td>
</tr>
<tr>
<td>⌘ + ⇧ + F</td>
<td>在全工程查找</td>
</tr>
<tr>
<td>⌘ + ⇧ + ⌥ + N</td>
<td>查找类中的方法或变量</td>
</tr>
<tr>
<td>F3 / ⇧ + F3</td>
<td>移动到搜索结果的下/上一匹配处</td>
</tr>
<tr>
<td>⌘ + R</td>
<td>在当前窗口替换</td>
</tr>
<tr>
<td>⌘ + ⇧ + R</td>
<td>在全工程替换</td>
</tr>
<tr>
<td>⌘ + ⇧ + V</td>
<td>可以将最近使用的剪贴板内容选择插入到文本</td>
</tr>
<tr>
<td>⌥ + ⇧ + Up/Down</td>
<td>向上/下移一行</td>
</tr>
<tr>
<td>⌘ + ⇧ + Up/Down</td>
<td>向上/下移动语句</td>
</tr>
<tr>
<td>⌘ + /</td>
<td>注释 - //</td>
</tr>
<tr>
<td>⌘ + ⇧ + /</td>
<td>注释 - /**/</td>
</tr>
<tr>
<td>⇧ + Enter</td>
<td>向下插入新行</td>
</tr>
<tr>
<td>⌘ + Enter</td>
<td>上插一行</td>
</tr>
<tr>
<td>⌘ + ⇧ + F7</td>
<td>高亮显示所有该文本，按 Esc 高亮消失</td>
</tr>
<tr>
<td>⌘ + W</td>
<td>可以选择单词继而语句继而行继而函数</td>
</tr>
<tr>
<td>⌘ + ⇧ + W</td>
<td>取消选择光标所在词</td>
</tr>
<tr>
<td>⌥ + Left/Right</td>
<td>移动光标到前/后单词</td>
</tr>
<tr>
<td>⌥ + Backspace</td>
<td>按单词删除</td>
</tr>
<tr>
<td>⌘ + [/]</td>
<td>移动到前/后代码块</td>
</tr>
<tr>
<td>⌘ + ⇧ + Left/Right/[/]</td>
<td>选中跳跃范围内的代码</td>
</tr>
<tr>
<td>⌘ + Y/X</td>
<td>删除行</td>
</tr>
<tr>
<td>⌘ + D</td>
<td>复制行</td>
</tr>
<tr>
<td>⌘ + ⇧ + U</td>
<td>大小写转化</td>
</tr>
<tr>
<td>⌘ + ⌥ + V</td>
<td>可以引入变量。例如：new String(); 自动导入变量定义</td>
</tr>
<tr>
<td>⌘ + ⌥ + T</td>
<td>可以把代码包在一个块内，例如：try/catch</td>
</tr>
<tr>
<td>⌘ + ⌥ + L</td>
<td>格式化代码</td>
</tr>
<tr>
<td>⌘ + ⌥ + I</td>
<td>将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作</td>
</tr>
<tr>
<td>⌘ + ⌥ + O</td>
<td>优化导入的类和包</td>
</tr>
<tr>
<td>⌘ + +/-</td>
<td>当前方法展开、折叠</td>
</tr>
<tr>
<td>⌘ + ⇧ + +/-</td>
<td>全部展开、折叠</td>
</tr>
</tbody></table>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>⌘ + ⇧ + ⌥ + T</td>
<td>重构功能大汇总快捷键</td>
</tr>
<tr>
<td>⇧ + F6</td>
<td>重命名</td>
</tr>
<tr>
<td>⌘ + ⌥ + V</td>
<td>提取变量</td>
</tr>
<tr>
<td>⌘ + O</td>
<td>重写父类方法</td>
</tr>
</tbody></table>
<h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>fori</td>
<td>生成循环</td>
</tr>
<tr>
<td>sout</td>
<td>System.out.println();</td>
</tr>
<tr>
<td>⌘ + J</td>
<td>可以查看所有代码模板</td>
</tr>
<tr>
<td>⌘ + ⌥ + J</td>
<td>用动态模板环绕</td>
</tr>
<tr>
<td>⌘ + ⇧ + Enter</td>
<td>自动补全末尾的字符（括号，分号），例如敲完if/for时也可以自动补上{}花括号。</td>
</tr>
<tr>
<td>⌥ + Enter</td>
<td>导入包，快速修复</td>
</tr>
</tbody></table>
<p>后缀自动补全功能(Postfix Completion)</p>
<ol>
<li>要输入 for(User user : users) 只需输入 user.for + Tab。</li>
<li>要输入 Date birthday = user.getBirthday(); 只需输入 user.getBirthday().var + Tab 即可。 |</li>
</ol>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>⌘ + Delete</td>
<td>删除文件</td>
</tr>
<tr>
<td>⌃ + ⌥ + N</td>
<td>新建一切文件</td>
</tr>
<tr>
<td>F5</td>
<td>复制类</td>
</tr>
<tr>
<td>F6</td>
<td>移动类</td>
</tr>
</tbody></table>
<h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>⌃ + H</td>
<td>打开类层次窗口，查看类的继承关系</td>
</tr>
<tr>
<td>⌘ + 1</td>
<td>快速打开或隐藏工程面板</td>
</tr>
<tr>
<td>⇧ + Esc</td>
<td>不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口</td>
</tr>
</tbody></table>
<h3 id="查找定位"><a href="#查找定位" class="headerlink" title="查找定位"></a>查找定位</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>⌘ + F7</td>
<td>可以查询当前元素在当前文件中的引用，然后按 F3 可以选择</td>
</tr>
<tr>
<td>⌥ + F7</td>
<td>查找整个工程中使用地某一个类、方法或者变量的位置</td>
</tr>
<tr>
<td>⇧ + ⇧</td>
<td>Search Everywhere 功能，可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等</td>
</tr>
<tr>
<td>⌘ + N</td>
<td>快速打开某个类</td>
</tr>
<tr>
<td>⌘ + ⇧ + N</td>
<td>快速打开文件或资源</td>
</tr>
<tr>
<td>⌘ + B / ⌘ + Click</td>
<td>快速打开光标处的类或方法（跳转到定义处）</td>
</tr>
<tr>
<td>⌘ + ⌥ + B</td>
<td>跳转到方法实现处</td>
</tr>
<tr>
<td>F2 / ⇧ + F2</td>
<td>移动到有错误的代码</td>
</tr>
<tr>
<td>⌘ + U</td>
<td>转到父类</td>
</tr>
<tr>
<td>⌘ + G</td>
<td>定位行</td>
</tr>
<tr>
<td>⌘ + ⌥ + left/right</td>
<td>返回至上次浏览的位置</td>
</tr>
<tr>
<td>⌘ + E</td>
<td>最近的文件</td>
</tr>
<tr>
<td>⌘ + ⇧ + E</td>
<td>最近更改的文件</td>
</tr>
<tr>
<td>⌥ + ⇧ + C</td>
<td>最近的更改</td>
</tr>
<tr>
<td>⌥ + F1</td>
<td>查找代码所在位置</td>
</tr>
<tr>
<td>⌘ + ⌥ + F7</td>
<td>显示用法</td>
</tr>
<tr>
<td>⌘ + I</td>
<td>实现方法</td>
</tr>
<tr>
<td>⌘ + ⌥ + N</td>
<td>内联</td>
</tr>
</tbody></table>
<p>方法相关</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>⌘ + P</td>
<td>可以显示参数信息</td>
</tr>
<tr>
<td>⌘ + F12</td>
<td>查看当前文件的结构</td>
</tr>
</tbody></table>
<p>调试部分、编译</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>⌘ + F2</td>
<td>停止</td>
</tr>
<tr>
<td>⌥ + ⇧ + F9</td>
<td>选择 Debug</td>
</tr>
<tr>
<td>⌥ + ⇧ + F10</td>
<td>选择 Run</td>
</tr>
<tr>
<td>⌘ + ⇧ + F9</td>
<td>编译</td>
</tr>
<tr>
<td>⌘ + ⇧ + F10</td>
<td>运行</td>
</tr>
<tr>
<td>⌘ + ⇧ + F8</td>
<td>查看断点</td>
</tr>
<tr>
<td>F7</td>
<td>步入 Step into</td>
</tr>
<tr>
<td>F8</td>
<td>步过 Step over</td>
</tr>
<tr>
<td>F9</td>
<td>恢复程序 Continue</td>
</tr>
<tr>
<td>⇧ + F7</td>
<td>智能步入</td>
</tr>
<tr>
<td>⇧ + F8</td>
<td>步出</td>
</tr>
<tr>
<td>⌥ + ⇧ + F8</td>
<td>强制步过</td>
</tr>
<tr>
<td>⌥ + ⇧ + F7</td>
<td>强制步入</td>
</tr>
<tr>
<td>⌥ + F9</td>
<td>运行至光标处</td>
</tr>
<tr>
<td>⌥ + F10</td>
<td>定位到断点</td>
</tr>
<tr>
<td>⌘ + ⌥ + F9</td>
<td>强制运行至光标处</td>
</tr>
<tr>
<td>⌘ + F8</td>
<td>切换行断点</td>
</tr>
<tr>
<td>⌘ + F9</td>
<td>生成项目</td>
</tr>
<tr>
<td>⌘ + ⇧ + C</td>
<td>复制路径</td>
</tr>
<tr>
<td>⌘ + ⌥ + ⇧ + C</td>
<td>复制引用，必须选择类名</td>
</tr>
<tr>
<td>⌘ + ⌥ + Y</td>
<td>同步</td>
</tr>
<tr>
<td>⌘ + ~</td>
<td>快速切换方案（界面外观、代码风格、快捷键映射等菜单）</td>
</tr>
<tr>
<td>⇧ + F12</td>
<td>还原默认布局</td>
</tr>
<tr>
<td>⌘ + ⇧ + F12</td>
<td>隐藏/恢复所有窗口</td>
</tr>
<tr>
<td>⌘ + F4</td>
<td>关闭</td>
</tr>
<tr>
<td>⌘ + ⇧ + F4</td>
<td>关闭活动选项卡</td>
</tr>
<tr>
<td>⌘ + Tab</td>
<td>转到下一个拆分器</td>
</tr>
<tr>
<td>⌘ + ⇧ + Tab</td>
<td>转到上一个拆分器</td>
</tr>
</tbody></table>
<h3 id="切换窗口"><a href="#切换窗口" class="headerlink" title="切换窗口"></a>切换窗口</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>⌘ + 1</td>
<td>项目结构</td>
</tr>
<tr>
<td>⌘ + 2</td>
<td>收藏</td>
</tr>
<tr>
<td>⌘ + 3</td>
<td>搜索结果</td>
</tr>
<tr>
<td>⌘ + 4</td>
<td>运行</td>
</tr>
<tr>
<td>⌘ + 5</td>
<td>调试</td>
</tr>
<tr>
<td>⌘ + 6</td>
<td>TODO</td>
</tr>
<tr>
<td>⌘ + 7</td>
<td>结构</td>
</tr>
<tr>
<td>⌃ + Tab</td>
<td>切换 tab</td>
</tr>
</tbody></table>
<p>其他</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>⌘ + ⇧ + A</td>
<td>可以查找所有命令，并且每个命令后面还有其快捷键</td>
</tr>
<tr>
<td></td>
<td>在任意菜单或显示窗口，都可以直接输入你要找的单词，idea 就会自动为你过滤。</td>
</tr>
</tbody></table>
<p>测试</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>⌘ + ⌥ + T</td>
<td>创建单元测试用例</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://timasura.github.io/2019/07/19/IDEA/" data-id="cjy9w8lhj0009lmwizhqg91zg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDEA快捷键/">IDEA快捷键</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-equals和==的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/equals和==的区别/" class="article-date">
  <time datetime="2019-07-17T03:31:16.169Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="equals和-的区别"><a href="#equals和-的区别" class="headerlink" title="equals和==的区别"></a>equals和==的区别</h2><p><strong>== 比较的是变量(栈)内存中存放的对象的(堆)内存地址</strong></p>
<p><strong>equals用来比较的是两个对象的内容是否相等。如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。</strong></p>
<h2 id="java-lang-Object"><a href="#java-lang-Object" class="headerlink" title="java.lang.Object"></a><strong>java.lang.Object</strong></h2><p>equals</p>
<p>hashCode</p>
<p>toString</p>
<p>clone</p>
<p>getClass</p>
<p>fin</p>
<p>wait</p>
<p>notify</p>
<h2 id="Static-用法"><a href="#Static-用法" class="headerlink" title="Static 用法"></a>Static 用法</h2><p>static修饰的方法、类变量叫做静态方法和静态变量，可以通过类名直接访问，被所有的对象所共享，初次加载时会被初始化。另外可以编写static代码块，静态导包</p>
<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><p>1、栈区：存放函数的参数值、局部变量、基本数据类型、对象的地址等，由编译器自动分配和释放，通常在函数执行完后就释放了，</p>
<p>2、堆区：就是通过new、malloc、realloc分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。</p>
<h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的</p>
<ol start="2">
<li>int 和Integer在进行比较的时候，Integer会进行拆箱，转为int值与int进行比较。</li>
<li>Integer与Integer比较的时候，由于直接赋值的时候会进行自动的装箱，那么这里就需要注意两个问题，一个是-128&lt;= x&lt;=127的整数，将会直接缓存在IntegerCache中，那么当赋值在这个区间的时候，不会创建新的Integer对象，而是从缓存中获取已经创建好的Integer对象。二：当大于这个范围的时候，直接new Integer来创建Integer对象。</li>
<li>new Integer(1) 和Integer a = 1不同，前者会创建对象，存储在堆中，而后者因为在-128到127的范围内，不会创建新的对象，而是从IntegerCache中获取的。那么Integer a = 128, 大于该范围的话才会直接通过new Integer（128）创建对象，进行装箱。</li>
</ol>
<h2 id="索引的原理"><a href="#索引的原理" class="headerlink" title="索引的原理"></a>索引的原理</h2><p><strong>InnoDB存储引擎</strong></p>
<p><strong>MyISAM存储引擎</strong></p>
<p><strong>MEMORY存储引擎</strong></p>
<table>
<thead>
<tr>
<th><strong>功 能</strong></th>
<th><strong>MYISAM</strong></th>
<th><strong>Memory</strong></th>
<th><strong>InnoDB</strong></th>
<th><strong>Archive</strong></th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>256TB</td>
<td>RAM</td>
<td>64TB</td>
<td>None</td>
</tr>
<tr>
<td>支持事物</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持全文索引</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>支持数索引</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持哈希索引</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>支持数据缓存</td>
<td>No</td>
<td>N/A</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>支持外键</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody></table>
<h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据  innodb</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行 MYISAM</li>
</ul>
<h1 id="synchronized与Lock的区别"><a href="#synchronized与Lock的区别" class="headerlink" title="synchronized与Lock的区别"></a><a href="https://www.cnblogs.com/iyyy/p/7993788.html" target="_blank" rel="noopener">synchronized与Lock的区别</a></h1><p>两者区别：</p>
<p>1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</p>
<p>2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</p>
<p>3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</p>
<p>4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</p>
<p>5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</p>
<p>6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</p>
<p>1、Lock是java的一个interface接口，而synchronized是Java中的关键字，synchronized是由JDK实现的，不需要程序员编写代码去控制加锁和释放；Lock的接口如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">    void lock();</span><br><span class="line">    void lockInterruptibly() throws InterruptedException;</span><br><span class="line">    boolean tryLock();</span><br><span class="line">    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">    void unlock();</span><br><span class="line">    Condition newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、synchronized修饰的代码在执行异常时，jdk会自动释放线程占有的锁，不需要程序员去控制释放锁，因此不会导致死锁现象发生；但是，当Lock发生异常时，如果程序没有通过unLock()去释放锁，则很可能造成死锁现象，因此Lock一般都是在finally块中释放锁；格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new LockImpl; // new 一个Lock的实现类</span><br><span class="line">lock.lock();  // 加锁</span><br><span class="line">try&#123;</span><br><span class="line">    //todo</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">     // todo</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    lock.unlock();   //释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、Lock可以让等待锁的线程响应中断处理，如tryLock(long time, TimeUnit unit)，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够中断，程序员无法控制；<br>　　4、通过Lock可以知道有没有成功获取锁，tryLock()方法返回boolean值，因此可知道是否获得了锁，而synchronized却无法办到。<br>　　5、Lock的实现类ReentrantReadWriteLock提供了readLock()和writeLock()用来获取读锁和写锁的两个方法，这样多个线程可以进行同时读操作。</p>
<h2 id="总体来讲，当并发量较小，资源竞争不激烈时，两者的性能是差不多的；当大量线程同时竞争，资源非常有限时，此时Lock的性能要远远优于synchronized。"><a href="#总体来讲，当并发量较小，资源竞争不激烈时，两者的性能是差不多的；当大量线程同时竞争，资源非常有限时，此时Lock的性能要远远优于synchronized。" class="headerlink" title="　　总体来讲，当并发量较小，资源竞争不激烈时，两者的性能是差不多的；当大量线程同时竞争，资源非常有限时，此时Lock的性能要远远优于synchronized。 "></a>　　总体来讲，当并发量较小，资源竞争不激烈时，两者的性能是差不多的；当大量线程同时竞争，资源非常有限时，此时Lock的性能要远远优于synchronized。 </h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://timasura.github.io/2019/07/17/equals和==的区别/" data-id="cjy9w8lh50002lmwiydyuo4pm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-proint" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/15/proint/" class="article-date">
  <time datetime="2019-07-15T02:01:28.000Z" itemprop="datePublished">2019-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/15/proint/">proint</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="注解（Annotation）"><a href="#注解（Annotation）" class="headerlink" title="注解（Annotation）"></a>注解（Annotation）</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li><p>@Target</p>
<ul>
<li><p>@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。</p>
<p><strong>作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</strong></p>
<p><strong>取值(ElementType)有：</strong></p>
<p>​    1.CONSTRUCTOR:用于描述构造器</p>
<p>​    2.FIELD:用于描述域<br>​    3.LOCAL_VARIABLE:用于描述局部变量<br>​    4.METHOD:用于描述方法<br>​    5.PACKAGE:用于描述包<br>​    6.PARAMETER:用于描述参数<br>​    7.TYPE:用于描述类、接口(包括注解类型) 或enum声明</p>
</li>
</ul>
</li>
<li><p>@Retention</p>
<ul>
<li><p><strong>@Retention</strong>定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。</p>
<p><strong>作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</strong></p>
<p><strong>取值（RetentionPoicy）有：</strong></p>
<p>　　1.SOURCE:在源文件中有效（即源文件保留）<br>　　2.CLASS:在class文件中有效（即class保留）<br>　　3.RUNTIME:在运行时有效（即运行时保留）</p>
</li>
</ul>
</li>
<li><p>@Documented</p>
<ul>
<li><strong>@Documented</strong> 标记注解 ：文档化注解生成公共API</li>
</ul>
</li>
<li><p>@Inherited</p>
<ul>
<li><strong>@Inherited</strong> 标记注解：如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>自定义注解</strong></p>
<ul>
<li><p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口。</p>
</li>
<li><p><strong>注解参数的可支持数据类型：</strong></p>
<p>　　1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)<br>　　2.String类型<br>　　3.Class类型<br>　　4.enum类型<br>　　5.Annotation类型<br>　　6.以上所有类型的数组</p>
<p>　　Annotation类型里面的参数该怎么设定:<br>　　第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；　 　<br>　　第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String;　　<br>　　第三,如果只有一个参数成员,最好把参数名称设为”value”,后加小括号.例:下面的例子FruitName注解就只有一个参数成员。</p>
</li>
</ul>
</li>
</ul>
<h3 id="自定义注解使用过程"><a href="#自定义注解使用过程" class="headerlink" title="自定义注解使用过程"></a>自定义注解使用过程</h3><h4 id="定义注解——配置注解——解析注解"><a href="#定义注解——配置注解——解析注解" class="headerlink" title="定义注解——配置注解——解析注解"></a><strong>定义注解——配置注解——解析注解</strong></h4><p><strong>一、 定义注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CherryAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</span><br><span class="line">    <span class="keyword">int</span>[] score();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二、 配置注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="meta">@CherryAnnotation</span>(name = <span class="string">"Tim"</span>,age = <span class="number">12</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">int</span> times)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Good Good Study, Day Day Up!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>三、 解析注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取Student的Class对象</span></span><br><span class="line">            Class stuClass = Class.forName(<span class="string">"pojos.Student"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//说明一下，这里形参不能写成Integer.class，应写为int.class</span></span><br><span class="line">            Method stuMethod = stuClass.getMethod(<span class="string">"study"</span>,<span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(stuMethod.isAnnotationPresent(CherryAnnotation.class))&#123;</span><br><span class="line">                System.out.println(<span class="string">"Student类上配置了CherryAnnotation注解！"</span>);</span><br><span class="line">                <span class="comment">//获取该元素上指定类型的注解</span></span><br><span class="line">                CherryAnnotation cherryAnnotation = stuMethod.getAnnotation(CherryAnnotation.class);</span><br><span class="line">                System.out.println(<span class="string">"name: "</span> + cherryAnnotation.name() + <span class="string">", age: "</span> + cherryAnnotation.age()</span><br><span class="line">                    + <span class="string">", score: "</span> + cherryAnnotation.score()[<span class="number">0</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Student类上没有配置CherryAnnotation注解！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p># </p>
<h1 id="github-com"><a href="#github-com" class="headerlink" title="github.com"></a>github.com</h1><p>74.86.151.162 <a href="http://global-ssl.fastly.net" target="_blank" rel="noopener">http://global-ssl.fastly.net</a><br>13.229.188.59 <a href="http://github.com" target="_blank" rel="noopener">http://github.com</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">74.86.151.162 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://timasura.github.io/2019/07/15/proint/" data-id="cjy9w8lhb0005lmwixld91o0t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/11/redis/" class="article-date">
  <time datetime="2019-07-11T00:53:56.000Z" itemprop="datePublished">2019-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/11/redis/">redis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="REDIS"><a href="#REDIS" class="headerlink" title="REDIS"></a>REDIS</h2><h3 id="0-Redis的五种数据类型和数据结构"><a href="#0-Redis的五种数据类型和数据结构" class="headerlink" title="0. Redis的五种数据类型和数据结构"></a>0. Redis的五种数据类型和数据结构</h3><p>如果你是 Redis 普通玩家，可能你的回答是如下五种数据结构：</p>
<ul>
<li>字符串 String<ul>
<li><strong>Redis的命令不区分大小写，但是key 严格区分大小写</strong></li>
<li>一个key 对应一个 value。string 类型是二进制安全的，意思是 Redis 的 string 可以包含任何数据，比如图片或者序列化的对象，一个 redis 中字符串 value 最多可以是 512M</li>
<li>set key1 value1  /  get key1</li>
<li>mset k1 v1 k2 v2 k3 v3 / mget k1 k3  :  mset 批量操作</li>
<li>setex kex 5 vex   设置过期时间    /    setnx  k8 v8   如果key存在不做任何操作</li>
<li>ttl  key 返回 key 的剩余过期时间，单位为秒</li>
<li>incr key    自增 key++ /  decr  key 自减 key–</li>
<li>incrby key i  key += i  /decrby key i  key -= i；</li>
</ul>
</li>
<li>字典Hash<ul>
<li>hset key field value [field value …]  新增  </li>
<li>hget key field [field …]  获取</li>
<li>hdel key field [field …]  删除</li>
<li>hexists key field  是否存在</li>
<li>hgetall key  获取所有keys和values</li>
<li>hincryby key field i   == key.field += i;</li>
<li>hkeys key  获取所有keys</li>
<li>hlen key  获取所有keys的个数</li>
<li>hmget key field [field …] </li>
<li>hmset key field value [field value …]</li>
<li>hvals key  获取所有values</li>
</ul>
</li>
<li>列表List</li>
<li>集合Set</li>
<li>有序集合 SortedSet</li>
</ul>
<p>如果你是 Redis 中级玩家，还需要加上下面几种数据结构：</p>
<ul>
<li>HyperLogLog</li>
<li>Geo</li>
<li>Pub / Sub</li>
</ul>
<p>如果你是 Redis 高端玩家，你可能玩过 Redis Module ，可以再加上下面几种数据结构：</p>
<ul>
<li>BloomFilter</li>
<li>RedisSearch</li>
<li>Redis-ML</li>
<li>JSON</li>
</ul>
<p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。😈 默默跟面试官在装一波。</p>
<h3 id="1-缓存穿透、缓存雪崩、缓存击穿"><a href="#1-缓存穿透、缓存雪崩、缓存击穿" class="headerlink" title="1. 缓存穿透、缓存雪崩、缓存击穿"></a>1. 缓存穿透、缓存雪崩、缓存击穿</h3><h3 id="2-Redis-使用场景"><a href="#2-Redis-使用场景" class="headerlink" title="2. Redis 使用场景"></a>2. Redis 使用场景</h3><p>Redis 可用的场景非常之多：</p>
<ul>
<li>数据缓存</li>
<li>会话缓存</li>
<li>时效性数据</li>
<li>访问频率</li>
<li>计数器</li>
<li>社交列表</li>
<li>记录用户判定信息</li>
<li>交集、并集和差集</li>
<li>热门列表与排行榜</li>
<li>最新动态</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
<p>详细的介绍，可以看看如下文章：</p>
<ul>
<li><a href="http://blog.720ui.com/2017/redis_core_use/" target="_blank" rel="noopener">《聊聊 Redis 使用场景》</a></li>
<li><a href="https://www.jianshu.com/p/af277c77b1c9" target="_blank" rel="noopener">《Redis 应用场景及实例》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29665317" target="_blank" rel="noopener">《Redis 常见的应用场景解析》</a></li>
<li><a href="https://www.zhihu.com/question/19829601" target="_blank" rel="noopener">《Redis 和 Memcached 各有什么优缺点，主要的应用场景是什么样的？》</a></li>
</ul>
<h3 id="3-Redis-提高命中率"><a href="#3-Redis-提高命中率" class="headerlink" title="3. Redis 提高命中率"></a>3. Redis 提高命中率</h3><h3 id="4-缓存算法"><a href="#4-缓存算法" class="headerlink" title="4. 缓存算法"></a>4. <strong>缓存算法</strong></h3><ul>
<li>LRU（least recently used ，最近最少使用)</li>
<li>LFU（Least Frequently used ，最不经常使用)</li>
<li>FIFO（first in first out ，先进先出)</li>
</ul>
<h3 id="5-常见问题"><a href="#5-常见问题" class="headerlink" title="5.常见问题"></a>5.常见问题</h3><ul>
<li>缓存何时<strong>写入</strong>？并且写时如何避免并发重复写入？</li>
<li>缓存如何<strong>失效</strong>？</li>
<li>缓存和 DB 的<strong>一致性</strong>如何保证？</li>
<li>如何避免缓存<strong>穿透</strong>的问题？</li>
<li>如何避免缓存<strong>击穿</strong>的问题？</li>
<li>如果避免缓存<strong>雪崩</strong>的问题？</li>
</ul>
<h3 id="6-什么是缓存预热？如何实现缓存预热？"><a href="#6-什么是缓存预热？如何实现缓存预热？" class="headerlink" title="6. 什么是缓存预热？如何实现缓存预热？"></a>6. 什么是缓存预热？如何实现缓存预热？</h3><h3 id="7-Redis-的优点、缺点"><a href="#7-Redis-的优点、缺点" class="headerlink" title="7.Redis 的优点、缺点"></a>7.Redis 的优点、缺点</h3><h3 id="8-Redis-的线程模型？为什么-Redis-单线程模型也能效率这么高？如何提高多核-CPU-的利用率？"><a href="#8-Redis-的线程模型？为什么-Redis-单线程模型也能效率这么高？如何提高多核-CPU-的利用率？" class="headerlink" title="8.Redis 的线程模型？为什么 Redis 单线程模型也能效率这么高？如何提高多核 CPU 的利用率？"></a>8.Redis 的线程模型？为什么 Redis 单线程模型也能效率这么高？如何提高多核 CPU 的利用率？</h3><h3 id="9-Redis-有几种持久化方式？"><a href="#9-Redis-有几种持久化方式？" class="headerlink" title="9.Redis 有几种持久化方式？"></a>9.Redis 有几种持久化方式？</h3><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？</p>
<h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>redis 如果仅仅只是将数据缓存在内存里面，如果 redis 宕机了再重启，内存里的数据就全部都弄丢了啊。你必须得用 redis 的持久化机制，将数据写入内存的同时，异步的慢慢的将数据写入磁盘文件里，进行持久化。</p>
<p>如果 redis 宕机重启，自动从磁盘上加载之前持久化的一些数据就可以了，也许会丢失少许数据，但是至少不会将所有数据都弄丢。</p>
<p>这个其实一样，针对的都是 redis 的生产环境可能遇到的一些问题，就是 redis 要是挂了再重启，内存里的数据不就全丢了？能不能重启的时候把数据给恢复了？</p>
<h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>持久化主要是做灾难恢复、数据恢复，也可以归类到高可用的一个环节中去，比如你 redis 整个挂了，然后 redis 就不可用了，你要做的事情就是让 redis 变得可用，尽快变得可用。</p>
<p>重启 redis，尽快让它对外提供服务，如果没做数据备份，这时候 redis 启动了，也不可用啊，数据都没了。</p>
<p>很可能说，大量的请求过来，缓存全部无法命中，在 redis 里根本找不到数据，这个时候就死定了，出现<strong>缓存雪崩</strong>问题。所有请求没有在 redis 命中，就会去 mysql 数据库这种数据源头中去找，一下子 mysql 承接高并发，然后就挂了…</p>
<p>如果你把 redis 持久化做好，备份和恢复方案做到企业级的程度，那么即使你的 redis 故障了，也可以通过备份数据，快速恢复，一旦恢复立即对外提供服务。</p>
<h3 id="redis-持久化的两种方式"><a href="#redis-持久化的两种方式" class="headerlink" title="redis 持久化的两种方式"></a>redis 持久化的两种方式</h3><ul>
<li>RDB：RDB 持久化机制，是对 redis 中的数据执行<strong>周期性</strong>的持久化。</li>
<li>AOF：AOF 机制对每条写入命令作为日志，以 <code>append-only</code> 的模式写入一个日志文件中，在 redis 重启的时候，可以通过<strong>回放</strong> AOF 日志中的写入指令来重新构建整个数据集。</li>
</ul>
<p>通过 RDB 或 AOF，都可以将 redis 内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务。</p>
<p>如果 redis 挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动 redis，redis 就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。</p>
<p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</p>
<h4 id="RDB-优缺点"><a href="#RDB-优缺点" class="headerlink" title="RDB 优缺点"></a>RDB 优缺点</h4><ul>
<li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，<strong>非常适合做冷备</strong>，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。</li>
<li>RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis <strong>保持高性能</strong>，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li>
<li>相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。</li>
<li>如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。</li>
<li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li>
</ul>
<h4 id="AOF-优缺点"><a href="#AOF-优缺点" class="headerlink" title="AOF 优缺点"></a>AOF 优缺点</h4><ul>
<li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次<code>fsync</code>操作，最多丢失 1 秒钟的数据。</li>
<li>AOF 日志文件以 <code>append-only</code> 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</li>
<li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 <code>rewrite</code> log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</li>
<li>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常<strong>适合做灾难性的误删除的紧急恢复</strong>。比如某人不小心用 <code>flushall</code> 命令清空了所有数据，只要这个时候后台 <code>rewrite</code> 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 <code>flushall</code> 命令给删了，然后再将该 <code>AOF</code> 文件放回去，就可以通过恢复机制，自动恢复所有数据。</li>
<li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</li>
<li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 <code>fsync</code> 一次日志文件，当然，每秒一次 <code>fsync</code>，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低）</li>
<li>以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是<strong>基于当时内存中的数据进行指令的重新构建</strong>，这样健壮性会好很多。</li>
</ul>
<h3 id="RDB-和-AOF-到底该如何选择"><a href="#RDB-和-AOF-到底该如何选择" class="headerlink" title="RDB 和 AOF 到底该如何选择"></a>RDB 和 AOF 到底该如何选择</h3><ul>
<li>不要仅仅使用 RDB，因为那样会导致你丢失很多数据；</li>
<li>也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；</li>
<li>redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</li>
</ul>
<h3 id="10-Redis-有几种数据“过期”策略？Redis-有哪几种数据“淘汰”策略？"><a href="#10-Redis-有几种数据“过期”策略？Redis-有哪几种数据“淘汰”策略？" class="headerlink" title="10.Redis 有几种数据“过期”策略？Redis 有哪几种数据“淘汰”策略？"></a>10.Redis 有几种数据“过期”策略？Redis 有哪几种数据“淘汰”策略？</h3><h3 id="11-如何使用-Redis-实现分布式锁？"><a href="#11-如何使用-Redis-实现分布式锁？" class="headerlink" title="11.如何使用 Redis 实现分布式锁？"></a>11.如何使用 Redis 实现分布式锁？</h3><h3 id="12-什么是-Redis-事务？"><a href="#12-什么是-Redis-事务？" class="headerlink" title="12.什么是 Redis 事务？"></a>12.什么是 Redis 事务？</h3><h3 id="13-什么是-Redis-主从同步？-Redis-分区"><a href="#13-什么是-Redis-主从同步？-Redis-分区" class="headerlink" title="13.什么是 Redis 主从同步？ Redis 分区"></a>13.什么是 Redis 主从同步？ Redis 分区</h3><p><a href="https://segmentfault.com/a/1190000014507534" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014507534</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://timasura.github.io/2019/07/11/redis/" data-id="cjy9w8lhk000almwiexaoirw5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/08/sort/" class="article-date">
  <time datetime="2019-07-08T00:39:09.000Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/08/sort/">sort</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h2><p><img src="/Users/kelvin/Desktop/sort.jpeg" alt="sort"></p>
<p><img src="https://img-blog.csdn.net/201807222219527?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODMzMzU1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://timasura.github.io/2019/07/08/sort/" data-id="cjy9w8lhd0006lmwilb26taa7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-two" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/05/two/" class="article-date">
  <time datetime="2019-07-05T05:21:31.000Z" itemprop="datePublished">2019-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/05/two/">two</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HashMap的扩容机制—resize()</p>
<p>面试的时候闻到了Hashmap的扩容机制，之前只看到了Hasmap的实现机制，补一下基础知识，讲的非常好</p>
<p>原文链接：</p>
<p><a href="http://www.iteye.com/topic/539465" target="_blank" rel="noopener">http://www.iteye.com/topic/539465</a></p>
<p>Hashmap是一种非常常用的、应用广泛的数据类型，最近研究到相关的内容，就正好复习一下。网上关于hashmap的文章很多，但到底是自己学习的总结，就发出来跟大家一起分享，一起讨论。</p>
<p>1、hashmap的数据结构<br>要知道hashmap是什么，首先要搞清楚它的数据结构，在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap也不例外。Hashmap实际上是一个数组和链表的结合体（在数据结构中，一般称之为“链表散列“），请看下图（横排表示数组，纵排表示数组元素【实际上是一个链表】）。</p>
<p>从图中我们可以看到一个hashmap就是一个数组结构，当新建一个hashmap的时候，就会初始化一个数组。我们来看看java代码：</p>
<p>Java代码  收藏代码<br>/**<br>     * The table, resized as necessary. Length MUST Always be a power of two.<br>     *  FIXME 这里需要注意这句话，至于原因后面会讲到<br>     */<br>    transient Entry[] table;</p>
<p>Java代码  收藏代码<br>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>        final K key;<br>        V value;<br>        final int hash;<br>        Entry&lt;K,V&gt; next;<br>……….<br>}</p>
<p>上面的Entry就是数组中的元素，它持有一个指向下一个元素的引用，这就构成了链表。<br>     当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。从这里我们可以想象得到，如果每个位置上的链表只有一个元素，那么hashmap的get效率将是最高的，但是理想总是美好的，现实总是有困难需要我们去克服，哈哈~</p>
<p>2、hash算法<br>我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。</p>
<p>所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那？java中时这样做的，</p>
<p>Java代码  收藏代码<br>static int indexFor(int h, int length) {<br>       return h &amp; (length-1);<br>   }</p>
<p>首先算得key得hashcode值，然后跟数组的长度-1做一次“与”运算（&amp;）。看上去很简单，其实比较有玄机。比如数组的长度是2的4次方，那么hashcode就会和2的4次方-1做“与”运算。很多人都有这个疑问，为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高，我以2的4次方举例，来解释一下为什么数组大小为2的幂时hashmap访问的性能最高。</p>
<pre><code>看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！




 所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。
 说到这里，我们再回头看一下hashmap中默认的数组大小是多少，查看源代码可以得知是16，为什么是16，而不是15，也不是20呢，看到上面annegu的解释之后我们就清楚了吧，显然是因为16是2的整数次幂的原因，在小数据量的情况下16比15和20更能减少key之间的碰撞，而加快查询的效率。</code></pre><p>所以，在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的，代码如下(HashMap的构造方法中)：</p>
<p>Java代码  收藏代码<br>// Find a power of 2 &gt;= initialCapacity<br>        int capacity = 1;<br>        while (capacity &lt; initialCapacity)<br>            capacity &lt;&lt;= 1;</p>
<p>总结：<br>        本文主要描述了HashMap的结构，和hashmap中hash函数的实现，以及该实现的特性，同时描述了hashmap中resize带来性能消耗的根本原因，以及将普通的域模型对象作为key的基本要求。尤其是hash函数的实现，可以说是整个HashMap的精髓所在，只有真正理解了这个hash函数，才可以说对HashMap有了一定的理解。</p>
<p>3、hashmap的resize</p>
<pre><code>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。

  那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。</code></pre><p>4、key的hashcode与equals方法改写<br>在第一部分hashmap的数据结构中，annegu就写了get方法的过程：首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。</p>
<p>Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。<br>在改写equals方法的时候，需要满足以下三点：<br>(1) 自反性：就是说a.equals(a)必须为true。<br>(2) 对称性：就是说a.equals(b)=true的话，b.equals(a)也必须为true。<br>(3) 传递性：就是说a.equals(b)=true，并且b.equals(c)=true的话，a.equals(c)也必须为true。<br>通过改写key对象的equals和hashcode方法，我们可以将任意的业务对象作为map的key(前提是你确实有这样的需要)。</p>
<p>总结：<br>        本文主要描述了HashMap的结构，和hashmap中hash函数的实现，以及该实现的特性，同时描述了hashmap中resize带来性能消耗的根本原因，以及将普通的域模型对象作为key的基本要求。尤其是hash函数的实现，可以说是整个HashMap的精髓所在，只有真正理解了这个hash函数，才可以说对HashMap有了一定的理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://timasura.github.io/2019/07/05/two/" data-id="cjy9w8lhl000clmwibdiiistn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-HashMap-扩容/">Java HashMap 扩容</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-first" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/05/first/" class="article-date">
  <time datetime="2019-07-05T05:16:01.000Z" itemprop="datePublished">2019-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/05/first/">first</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一，Java 位运算</p>
<p>1.表示方法： 　</p>
<p>在Java语言中，二进制数使用补码表示，最高位为符号位，正数的符号位为0，负数为1。补码的表示需要满足如下要求。 　</p>
<p>(1)正数的最高位为0，其余各位代表数值本身(二进制数)。 　</p>
<p>(2)对于负数，通过对该数绝对值的补码按位取反，再对整个数加1。</p>
<p>2.位运算符 　</p>
<p>位运算表达式由操作数和位运算符组成，实现对整数类型的二进制数进行位运算。位运算符可以分为逻辑运算符(包括~、＆、|和^)及移位运算符(包括&gt;&gt;、&lt;&lt;和&gt;&gt;&gt;)。</p>
<p>1)左移位运算符（&lt;&lt;）能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补0）。</p>
<p>2)“有符号”右移位运算符（&gt;&gt;）则将运算符左边的运算对象向右移动运算符右侧指定的位数。 “有符号”右移位运算符使用了“符号扩展”：若值为正，则在高位插入0；若值为负，则在高位插入1。</p>
<p>3)Java也添加了一种“无符号”右移位运算符（&gt;&gt;&gt;），它使用了“零扩展”：无论正负，都在高位插入0。这一运算符是C或C++没有的。</p>
<p>4)若对char，byte或者short进行移位处理，那么在移位进行之前，它们会自动转换成一个int。 只有右侧的5个低位才会用到。这样可防止我们在一个int数里移动不切实际的位数。 若对一个long值进行处理，最后得到的结果也是long。此时只会用到右侧的6个低位，防止移动超过long值里现成的位数。 但在进行“无符号”右移位时，也可能遇到一个问题。若对byte或short值进行右移位运算，得到的可能不是正确的结果（Java 1.0和Java 1.1特别突出）。 它们会自动转换成int类型，并进行右移位。但“零扩展”不会发生，所以在那些情况下会得到-1的结果。</p>
<p>在进行位运算时，需要注意以下几点。 　　</p>
<p>(1)&gt;&gt;&gt;和&gt;&gt;的区别是：在执行运算时，&gt;&gt;&gt;运算符的操作数高位补0，而&gt;&gt;运算符的操作数高位移入原来高位的值。 　　</p>
<p>(2)右移一位相当于除以2，左移一位(在不溢出的情况下)相当于乘以2；移位运算速度高于乘除运算。 　　</p>
<p>(3)若进行位逻辑运算的两个操作数的数据长度不相同，则返回值应该是数据长度较长的数据类型。 　　</p>
<p>(4)按位异或可以不使用临时变量完成两个值的交换，也可以使某个整型数的特定位的值翻转。 　　</p>
<p>(5)按位与运算可以用来屏蔽特定的位，也可以用来取某个数型数中某些特定的位。 　　</p>
<p>(6)按位或运算可以用来对某个整型数的特定位的值置l。</p>
<p>3．位运算符的优先级 　</p>
<p>~的优先级最高，其次是&lt;&lt;、&gt;&gt;和&gt;&gt;&gt;，再次是＆，然后是^，优先级最低的是|。</p>
<p>二， 按位异或运算符^</p>
<p> 参与运算的两个值，如果两个相应位相同，则结果为0，否则为1。即：0^0=0， 1^0=1， 0^1=1， 1^1=0</p>
<p>例如：10100001^00010001=10110000</p>
<p>　　　0^0=0,0^1=1 0异或任何数＝任何数</p>
<p>　　　1^0=1,1^1=0 1异或任何数－任何数取反</p>
<p>　　　任何数异或自己＝把自己置0</p>
<p>(1)按位异或可以用来使某些特定的位翻转，如对数10100001的第2位和第3位翻转，可以将数与00000110进行按位异或运算。 　　　　　　　　　 　　　　　　　　　　10100001^00000110=10100111 //1010 0001 ^ 0x06 = 1010 0001 ^ 6</p>
<p>(2)通过按位异或运算，可以实现两个值的交换，而不必使用临时变量。</p>
<p>例如交换两个整数a，b的值，可通过下列语句实现：</p>
<p> a=10100001,b=00000110</p>
<p> a=a^b； 　　//a=10100111</p>
<p> b=b^a； 　　//b=10100001</p>
<p> a=a^b； 　　//a=00000110</p>
<p>(3)异或运算符的特点是：数a两次异或同一个数b（a=a^b^b）仍然为原值a.</p>
<p> 三，Java 中除了二进制的表示方法：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://timasura.github.io/2019/07/05/first/" data-id="cjy9w8lh00000lmwi79xe4w7f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-位运算/">JAVA 位运算</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA快捷键/">IDEA快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA-位运算/">JAVA 位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-HashMap-扩容/">Java HashMap 扩容</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IDEA快捷键/" style="font-size: 10px;">IDEA快捷键</a> <a href="/tags/JAVA-位运算/" style="font-size: 10px;">JAVA 位运算</a> <a href="/tags/Java-HashMap-扩容/" style="font-size: 10px;">Java HashMap 扩容</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/19/studay1/">studay1</a>
          </li>
        
          <li>
            <a href="/2019/07/19/IDEA/">IDEA</a>
          </li>
        
          <li>
            <a href="/2019/07/17/equals和==的区别/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/07/15/proint/">proint</a>
          </li>
        
          <li>
            <a href="/2019/07/11/redis/">redis</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Kelvin Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>